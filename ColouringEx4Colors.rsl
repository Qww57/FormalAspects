ColouringBasics

scheme ColouringEx =
extend ColouringBasics with 
	class
	
		value			
		
		
		/* We have 4 lists for 4 colors and a list that has all the pieces
		 * we have 4 function for these 4 list
		 * 
		 */ 
		isNeighbourInColour : Piece >< Relation >< Colour -> Bool
		isNeighbourInColour(cn1, r, colour) is
			(exists p1 : Piece :- p1 isin colour /\ areNb(p1, cn1, r)),
		
		/* */
		reds : Colour-set,
		greens : Coluor-set,
		blues : Colour-set,
		whites : Colour-set,
		pieces : Piece-set, /*set that has all the pieces */
		
		
		addPieceToReds : Piece >< Relation -> Colouring
		addPieceToReds(cn1, r) is 
			if  
				card reds = 0
			then /* add new piece to reds and remove it from list of all the pieces */
				reds union {{cn1}} /\ {cn1} \ pieces
			else if /* make sure there are not any neighbor in the reds then add new piece to it */
				all p1 : Piece :- p1 isin r => ~areNb(p1, cn1, r) 
			then
				reds union {{cn1}} /\ {cn1} \ pieces
		end
		
		
		addPieceToGreens : Piece >< Relation -> Colouring
		addPieceToGreens(cn1, r) is 
				if  
					card greens = 0
				then /* add new piece to greens and remove it from list of all the pieces */
					greens union {{cn1}} /\ {cn1} \ pieces
				else if /* make sure there are not any neighbor in the greens then add new piece to it */
					all p1 : Piece :- p1 isin r => ~areNb(p1, cn1, r) 
				then
					greens union {{cn1}} /\ {cn1} \ pieces
			end,
		
		
		addPieceToBlues : Piece >< Relation -> Colouring
		addPieceToBlues(cn1, r) is 
				if  
					card blues = 0
				then /* add new piece to blues and remove it from list of all the pieces */
					blues union {{cn1}} /\ {cn1} \ pieces
				else if /* make sure there are not any neighbor in the blues then add new piece to it */
					all p1 : Piece :- p1 isin r => ~areNb(p1, cn1, r) 
				then
					blues union {{cn1}} /\ {cn1} \ pieces
			end,
			
			
		addPieceToWhites : Piece >< Relation -> Colouring
		addPieceToWhites(cn1, r) is 
				if  
					card whites = 0
				then /* add new piece to whites and remove it from list of all the pieces */
					whites union {{cn1}} /\ {cn1} \ pieces
				else if /* make sure there are not any neighbor in the whites then add new piece to it */
					all p1 : Piece :- p1 isin r => ~areNb(p1, cn1, r) 
				then
					whites union {{cn1}} /\ {cn1} \ pieces
			end,	
		
		
		/* Done */
		addPieceToColour : Piece >< Colour -> Colour
		addPieceToColour(cn1, colour) is 
			colour union {cn1},
			
		
		/* minColourNumber : Relation -> Int
		minColourNumber(r) is min 
			(all p1 : Piece :- p1 isin {let (p1, p2) = e in p1 end | e : Piece >< Piece :- e isin r} =>
				(all p2 : Piece :- p2 isin {let (p1, p2) = e in p2 end | e : Piece >< Piece :- e isin r} =>
					((p1, p2) isin r => (p1 ~= p2))
				)
			)
		post isCorrectColouring(cols, r) 	*/
		
		/* Return a correct colouring for the relation in input */
		/* col : Relation -~-> Colouring
		col(r) is ...,
		pre isRelation(r) */
	end	