scheme  ColouringBasics =
class
	type 
		Piece = Text,
		Relation = (Piece >< Piece)-set,
		Colour = Piece-set,
		Colouring = Colour-set
	    
	value 
		
		/* The point is to check if a piece is in the colouring (i.e. (Piece-set)-set)
		 *
		 * params
		 *		Piece - piece we want to check
		 *		Colouring - colouring which cotaining colours (Piece-set)
		 *
		 * returns 
		 * 		TRUE - if the piece is in the colour set
		 * 		FALSE - if the piece is not in the colour set	
		 */		 
		 isInColouring : Piece >< Colouring -> Bool
		 isInColouring(cn1, colouring) is 		 	
		 	(exists colour : Colour :- colour isin colouring /\ (exists p1 : Piece :- p1 isin colour /\ (p1 = cn1))), 
		
		
		/* Test if a couple in the relation has the same colouring
		 *
		 * params
		 *		Piece - first piece we want to test
		 *		Piece - second piece we want to test
		 *		Colouring - colouring which contains the colours
		 *
		 * returns 
		 * 		TRUE - if Piece already in colour set
		 * 		FALSE - if Piece not in color set		
		 */
		isSameColour : Piece >< Piece >< Colouring -> Bool
   		isSameColour(cn1, cn2, cols) is 
   			(exists colour1 : Colour :- colour1 isin cols /\ cn1 isin colour1 /\ 
   				(exists colour2 : Colour :- colour2 isin cols /\ cn2 isin colour2 /\ (colour1 = colour2)))		 
   		pre (isInColouring(cn1, cols) /\ isInColouring(cn2, cols)),
		
		
		/* Defining that for all pieces (p1, p2) defining couple in a relation, we have p1 different from p2
		 * The point is to check that the relation doesn't have any couple defined with the same piece.
		 * For instance: {p1, p1}
		 *
		 * params
		 *		Relation - relation we want to test
		 *
		 * returns 
		 * 		TRUE - if the relation is well-formated
		 * 		FALSE - if the relation is not well-formated
		 */
		isRelation : Relation -> Bool
		isRelation(r) is 
			/* p1 and p2 defined as a Piece which is part of a couple of pieces included in r */
			(all p1 : Piece :- p1 isin {let (p1, p2) = e in p1 end | e : Piece >< Piece :- e isin r} =>
				(all p2 : Piece :- p2 isin {let (p1, p2) = e in p2 end | e : Piece >< Piece :- e isin r} =>
					((p1, p2) isin r => (p1 ~= p2))
				)
			),	
		
		
		/* Defining two pieces p1 and p2 as parts of a couple which belongs to r, 
		 * then, we have the implication that if cn1 and cn2 are neighbour, they should be equal to p1 and p2.
		 *
		 * The point is to check that it exists (or not) two pieces (p1, p2) from the relation which are neighbours.
		 * Then, we check if these pieces are equals cn1 and cn2.
		 *
		 * params
		 *		Piece - first piece we want to check
		 * 		Piece - second piece we want to check
		 *		Relation - relation where are all the neighborhoods relation are defined
		 *
		 * returns 
		 * 		TRUE - if pieces are neighbors according to the relation
		 * 		FALSE - if pieces are not neighbors according to the relation
		 */
		areNb : Piece >< Piece >< Relation -> Bool
		areNb(cn1, cn2, r) is 
			(exists (p1, p2) : Piece >< Piece :- (p1, p2) isin r /\ ((cn1 = p1 /\ cn2 = p2) \/ (cn1 = p2 /\ cn2 = p1)))
		pre isRelation(r), 		
		
   		
		/* We want to check that for all piece, if couples of neighbours have different colours
		 *
		 * params
		 *		Colouring - colouring used on the pieces
		 *		Relation - relation defining neighborhood relations
		 *
		 * returns 
		 * 		TRUE - if colouring is done correctly
		 * 		FALSE - if colouring is not done correctly
		 */ 
    	isCorrectColouring : Colouring >< Relation -> Bool
   		isCorrectColouring(cols, r) is 
   			(all p1 : Piece :- p1 isin {let (p1, p2) = e in p1 end | e : Piece >< Piece :- e isin r} =>
				(all p2 : Piece :- p2 isin {let (p1, p2) = e in p2 end | e : Piece >< Piece :- e isin r} =>
					(areNb(p1, p2, r)) => ~isSameColour(p1, p2, cols)
				)
			)	
   		pre isRelation(r) 
 end