ColouringBasics

scheme ColouringEx =
extend ColouringBasics with 
	class
		value
	
		/* Check if the piece is in the colour (Piece-set) or not
		 *
		 * params
		 *		Piece - piece we want to test
		 *		Colour - current colour we want to test
		 *
		 * returns 
		 * 		TRUE - if Piece already in colour set
		 * 		FALSE - if Piece not in color set
		 */
		isInColour : Piece >< Colour -> Bool
		isInColour(cn1, colour) is 
			cn1 isin colour,
		
		/* Check if the piece can have or not the colour being tested.
		 * We are checking if there is a neighbour of the piece in the colour, 
		 * or if the piece is already in the colour.
		 *
		 * params
		 *		Piece - piece we want to check
		 * 		Relation - relation defining neighbourhood relations
		 *		Colour - current colour we want to test
		 *
		 * returns 
		 * 		TRUE - if Piece can be added to the colour
		 * 		FALSE - if Piece cannot be added to the colour
		 */ 
		canAddPieceToColour : Piece >< Relation >< Colour -> Bool
		canAddPieceToColour(cn1, r, colour) is
			~((exists p1 : Piece :- p1 isin colour /\ areNb(p1, cn1, r)) 
				\/ isInColour(cn1, colour)),
				
		/* Check if the piece can be added to the colors of the colouring
		 *
		 * params
		 *		Piece - piece we want to check
		 * 		Relation - relation defining neighbourhood relations
		 *		Colouring - Colouring to test
		 *
		 * returns 
		 * 		TRUE - if the piece can be added in a color of the colouring
		 * 		FALSE - if the piece cannot be added to the colour of the colouring
		 */ 
		canAddPieceToOneColour : Piece >< Relation >< Colouring -> Bool
		canAddPieceToOneColour(cn1, r, colouring) is
			(exists colour : Colour :- colour isin colouring /\ canAddPieceToColour(cn1, r, colour)),
	
		/* Add a piece to the current colour
		 *
		 * params
		 *		Piece - piece to add to the colour
		 * 		Relation - relation defining neighbourhood relations
		 *		Colour - current colour we want to add the piece
		 *
		 * returns
		 * 		Colour - colour in the parameters with potentially the new piece 
		 */
		addPieceToColour : Piece >< Relation >< Colour -> Colour
		addPieceToColour(cn1, r, colour) is 
			if canAddPieceToColour(cn1, r, colour)
			then colour union {cn1}
			else colour
			end,
		
		/* The purpose of this function is to start the treatment of the Colouring
		 *
		 * params
		 *		Piece - piece to add to the colour
		 * 		Relation - relation defining neighbourhood relations
		 *		Colour - current colour we want to add the piece
		 *
		 * returns
		 * 		Colour - colour in the parameters with potentially the new piece 
		 */
		startTreatment : Piece >< Relation >< Colouring -> Colouring
		startTreatment(cn1, r, colouring) is 
			if canAddPieceToOneColour(cn1, r, colouring) = true
			then {addPieceToColour(cn1, r, colour) |  colour : Colour :- colour isin colouring}
			else colouring union {{cn1}}
			end
			
		
		/* Return a correct colouring for the relation in input 
		 *
		 * params
		 * 		Relation - relation defining neighbourhood relations of piece we want to colour
		 *
		 * returns
		 * 		Colouring - set of colour considering neighbourhood relations
		 *
			(all p1 : Piece :- p1 isin {let (p1, p2) = e in p1 end | e : Piece >< Piece :- e isin r}  => startTreatment(p1, r, CurrentColouring))
		 
		col : Relation -~-> 
		col(r) is 
			let
				colouring : Colouring
			in 
				{startTreatment(p1, r, colouring) |  p1 : Piece :- p1 isin {let (p1, p2) = e in p1 end | e : Piece >< Piece :- e isin r}}
			end
		pre isRelation(r) */
		
end
