NET
scheme TIMETABLE = extend NET with
class
	type /* Time table type */
	
    	TimeTable = Plan-set,
    	
    	/* Auxiliary types */
    	
    	Plan:: tramId : TramId
	    	   trips : Trip-set <-> new_trips,
    
    	Trip:: stationId :StopId 
	   		arrivalTime : Time
	   		departureTime: Time,
	   		
	   	/* Simple predefined types */

    	TramId = Text -- tram names

    value /* generators */
    
      	-- the empty timetable
    	-- empty: TimeTable = TimeTable-set =,

      	-- add to a time table an empty plan for a new tram
      	addTram: TramId >< TimeTable -> TimeTable
      	addTram(trId, tt) is
	    	 {mk_Plan(trId, {})} union tt,

      	-- add a stop with arrival time and departure time to the plan for a given tram
      	addStop: TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      	addStop(trId, sId, at, dt, tt) is
		if isIn(trId, tt)
	    then let 
				plan = getPlanByTramId(trId, tt),
				tt = tt \ {plan} 
			in
				{new_trips({mk_Trip(sId, at, dt)} union trips(plan), plan)} union tt 
			end
		else {mk_Plan(trId, {mk_Trip(sId, at, dt)})} union tt
		end
		 
	value /* observers */
     
     	-- check whether a tram with a given name exists in a given time table
     	isIn : TramId >< TimeTable -> Bool
	 	isIn(trId, tt) is
			(exists plan : Plan :- plan isin tt /\ tramId(plan) = trId),

		-- check whether a stop with a given name exists in a given time table
    	stopIsIn : StopId >< TimeTable -> Bool
    	stopIsIn(id, t) is
    		(exists p : Plan :- p isin t /\
    			(exists t : Trip :- t isin trips(p) /\ stationId(t) = id)),

		/* Auxiliary functions for the Observers and Generators */
	
		getPlanByTramId: TramId >< TimeTable -> Plan
		getPlanByTramId(trId, tt) is
			let 
				head = hd tt,
	    		tail = tt \ {head} 		
	    	in
	    		if trId = tramId(head)
	    		then head 
	    		else getPlanByTramId(trId, tail)
	    		end
			end

 	 value /* predicates to check time tables */   
   		
   		--isWellformed : TimeTable >< Net -> Bool
     	--isWellformed(t, n) is ...,
			
		/* requirement that check if departure time and arrival time are not equal */	
		
		isADTimeAreDifferent: Trip -> Bool
		isADTimeAreDifferent(trip) is
				if( arrivalTime(trip) ~= departureTime(trip))
				then true
				else false
			end,				
		
		/* requirement that check that departure time
			should not be before arrival time  */
		
		isATimeBeforeDTime: Trip -> Bool
		isATimeBeforeDTime(trip) is
				if( arrivalTime(trip) < departureTime(trip))
				then true
				else false
			end,
			
		/* requirement that check if all the values are in range between 0 and 60  */
		
		areValuesinRange: Plan -> Bool
		areValuesinRange(plan) is
			~(exists trip : Trip :- trip isin trips(plan) /\ (arrivalTime(trip) < 0 \/
				arrivalTime(trip) > 60 \/ departureTime(trip) < 0 \/ departureTime(trip) > 60)),
    
    	-- 7) Respect of stop capacity
    	requirementSeven : TimeTable >< Net -> Bool
    	requirementSeven(t, n) is
    		false, --TODO
    
    	-- 10) All stops of the time table should be defined in the net
     	requirementTen : TimeTable >< Net -> Bool 
     	requirementTen(t, n) is
     		~(exists p : Plan :- p isin t /\ stopDefinition(p, n)),
     	
     	-- All stops of the trips of the plan are defined in the net 
     	stopDefinition : Plan >< Net -> Bool
     	stopDefinition(p, n) is 
     		~(exists t : Trip :- t isin trips(p) /\ isIn(stationId(t), n)),
     		
     	-- 11) All stops of the net are used at least once in the time table
     	requirementEleven : TimeTable >< Net -> Bool
     	requirementEleven(t, n) is
     		~(exists s : Stop :- s isin Stops(n) /\ ~stopIsIn(stopId(s), t)), 
     		
     	-- 12) All connections implicitely defined in the time table are also defined
     	-- in the net, last trip is not checked since same station than first one
     	requirementTwelve : TimeTable >< Net -> Bool
     	requirementTwelve(t, n) is 
     		~(exists p : Plan :- p isin t /\ 
     			(exists trip : Trip :- trip isin trips(p) /\ 
     				~areDirectlyConnected(stationId(trip), stationId(getNextTrip(p, trip)), n)
     				/\ departureTime(trip) ~= getLastTripDepartureTime(trips(p), 0)
     			)
     		),
     		
     	/* Auxiliary functions used in order to get the next trip of a given trip in a plan */	
     	
     	-- Get the next trip of a specific trip in a plan using the arrivalTime
     	getNextTrip : Plan >< Trip -> Trip
     	getNextTrip(p, trip) is
     		getTripByATime(trips(p), getNextTripArrivalTime(trips(p), trip)),
     	
     	-- Get the arrival time of a trip
     	getNextTripArrivalTime : Trip-set >< Trip -> Time 
     	getNextTripArrivalTime(p, t) is
     		if (departureTime(t) = getLastTripDepartureTime(p, 0))
     		then getFirstTripArrivalTime(p, 61) 
     		else getNextTripLoop(p, t, 61)
  			end,
  		
  		-- Return arrival time of the first trip
  		getFirstTripArrivalTime : Trip-set >< Time -> Time
  		getFirstTripArrivalTime(p, best) is 
  			if p ~= {}
  			then let head = hd p,
  			    	 tail = p \ {head}
  				in getFirstTripArrivalTime(tail, smallestAT(head, best))
  				end 
  			else best 
  			end, 
  				
  		-- Return the smallest of two values
  		smallestAT : Trip >< Time -> Time
  		smallestAT(head, best) is
  			if arrivalTime(head) < best 
  			then arrivalTime(head)
  			else best
  			end,
  			
  		-- Return arrival time of the first trip
  		getLastTripDepartureTime : Trip-set >< Time -> Time
  		getLastTripDepartureTime(p, best) is 
  			if p ~= {}
  			then let head = hd p,
  			    	 tail = p \ {head}
  				in getLastTripDepartureTime(tail, biggestDT(head, best))
  				end 
  			else best 
  			end, 
  				
  		-- Return the biggest of two values
  		biggestDT : Trip >< Time -> Time
  		biggestDT(head, best) is
  			if departureTime(head) > best 
  			then departureTime(head)
  			else best
  			end,
  			
  		-- Get trip from a set trip using its arrival time
     	getTripByATime : Trip-set >< Time -> Trip
     	getTripByATime(p, aTime) is 
     		let 
     			head = hd p, 
     			tail = p \ {head}
     		in
     			if arrivalTime(head) = aTime
     			then head
     			else getTripByATime(tail, aTime)
     			end
     		end,
     	
     	-- Function used in order to get the next trip of a given trip in a time table
     	getNextTripLoop : Trip-set >< Trip >< Time -> Time
     	getNextTripLoop(p, t, best) is 
     		if p ~= {}
     		then let head = hd p,
     				tail = p \{head}
     			 in insideFunction(t, head, tail, best)	
     			 end
     		else best
     		end,  
     		
     	-- Function used with getNextTripLoop
     	insideFunction : Trip >< Trip >< Trip-set >< Time -> Time
     	insideFunction(t, head, tail, best) is
     		if (departureTime(t) < arrivalTime(head) /\ arrivalTime(head) < best)
			then getNextTripLoop(tail, t , arrivalTime(head))
			else getNextTripLoop(tail, t , best)  	
			end	
     	  		 
end 